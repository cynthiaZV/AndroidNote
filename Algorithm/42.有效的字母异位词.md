42.有效的字母异位词
===


### 题目

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词。

 

示例 1:     

- 输入: s = "anagram", t = "nagaram"
- 输出: true

示例 2:   

- 输入: s = "rat", t = "car"
- 输出: false
 

提示:   

- 1 <= s.length, t.length <= 5 * 104
- s 和 t 仅包含小写字母
 

进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？


### 思路

设两字符串 s 
1
​	
  , s 
2
​	
  ，则两者互为重排的「充要条件」为：两字符串 s 
1
​	
  , s 
2
​	
  包含的字符是一致的，即 s 
1
​	
  , s 
2
​	
  所有对应字符数量都相同，仅排列顺序不同。

根据以上分析，可借助「哈希表」分别统计 s 
1
​	
  , s 
2
​	
  中各字符数量 key: 字符, value: 数量 ，分为以下情况：

若 s 
1
​	
  , s 
2
​	
  字符串长度不相等，则「不互为重排」；
若 s 
1
​	
  , s 
2
​	
  某对应字符数量不同，则「不互为重排」；
否则，若 s 
1
​	
  , s 
2
​	
  所有对应字符数量都相同，则「互为重排」；
具体上看，我们可以统计 s 
1
​	
  各字符时执行 +1 ，统计 s 
2
​	
  各字符时 −1 。若两字符串互为重排，则最终哈希表中所有字符统计数值都应为 0 。

作者：Krahets
链接：https://leetcode.cn/problems/valid-anagram/solutions/2362065/242-you-xiao-de-zi-mu-yi-wei-ci-ha-xi-bi-cch7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int len1 = s.length(), len2 = t.length();
        if (len1 != len2)
            return false;
        HashMap<Character, Integer> dic = new HashMap<>();
        for (int i = 0; i < len1; i++) {
            dic.put(s.charAt(i) , dic.getOrDefault(s.charAt(i), 0) + 1);
        }
        for (int i = 0; i < len2; i++) {
            dic.put(t.charAt(i) , dic.getOrDefault(t.charAt(i), 0) - 1);
        }
        for (int val : dic.values()) {
            if (val != 0)
                return false;
        }
        return true;
    }
}
```


```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        dic = defaultdict(int)
        for c in s:
            dic[c] += 1
        for c in t:
            dic[c] -= 1
        for val in dic.values():
            if val != 0:
                return False
        return True
```


复杂度分析:    

- 时间复杂度 O(M+N) ： 其 M , N 分别为字符串 s1, s2长度。当 s1, s2无相同字符时，三轮循环的总迭代次数最多为 2M+2N ，使用 O(M+N) 线性时间。

- 空间复杂度 O(1) ： 由于字符种类是有限的（常量），一般 ASCII 码共包含 128 个字符，因此可假设使用 O(1) 大小的额外空间。


对于进阶问题，Unicode 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。而 Unicode 中可能存在一个字符对应多个字节的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的 UTF−8 和 UTF−16 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。

回到本题，进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 Unicode 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。



```java

class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        Map<Character, Integer> table = new HashMap<Character, Integer>();
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            table.put(ch, table.getOrDefault(ch, 0) + 1);
        }
        for (int i = 0; i < t.length(); i++) {
            char ch = t.charAt(i);
            table.put(ch, table.getOrDefault(ch, 0) - 1);
            if (table.get(ch) < 0) {
                return false;
            }
        }
        return true;
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/valid-anagram/solutions/493231/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

复杂度分析

时间复杂度：O(n)，其中 n 为 s 的长度。

空间复杂度：O(S)，其中 S 为字符集大小，此处 S=26。



class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)


---
- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 

	
